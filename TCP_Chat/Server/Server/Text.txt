Клиент-серверное (сетевое) программирование

Сеть (компьютерная сеть, NETWORK, ! не путать с GRID)
	- совокупность узлов и каналов связи;
Узел (Node, Peer) - часть сети, устройство, способное выполнять программы/команды (активное устройство) 
Адрес узла - данные, позволяющие однозначно определить (локализовать) узел в сети.
IP, IP-адрес - числовой адрес, 32 бита (v4) / 128 бита (v6). 
Для упрощения применяются символьные записи IP, например, 127.0.0.1 или ::1

На одном сетевом узле могут выполнятся несколько программ, требующих данных из сети (Браузер, почта, обновления и т.п.).
Для их разделения, для адресации данных конкретному приложению, вводится понятие порта/
Порт (сетевой порт) - число, идентифицирующее приложение на узле.
Полный адрес приложения состоит из IP и порта и называется endpoint
записывается через ":" 127.0.0.1:80
Некоторые порты, традиционно, закреплены за некоторыми приложениями. 
• Не рекомендуется для "своих" целей использовать порты до 1024. 

Клиент - роль приложения - узел, посылающий запрос, инициатор коммуникации.
Сервер - роль - отвечающий на запрос
Одно и тоже приложение может играть любую из ролей, менять роли по ходу работы и даже играть обе роли одновременно
(запрашивать один сервер и отвечать другому)

Сокет - термин, скрывающий за собой технологию обмена данных между сетевыми узлами. 
Термины "записать в сокет", "прочитать из сокета" означают процессы обмена данными между приложениями, установившими связь
- "открывшими сокет"
Сокеты бывают односторонними (чтение либо запись) и двусторонними (дуплексными)

Основное поведение: 
Сервер - слушает порт: регистрирует в ОС, занимая за собой некоторый порт. ОС, получив сетевую активность с указанием этого
 порта, передает данные серверу
Клиент - соединяется (инициирует соединение) - посылает специальный запрос на endpoint, на котором должен быть сервер, если
 он там есть, то соединение устанавливается и открывается сокет.

Технические детали:
Сервер должен "Знать", к какому endpoint подключать прослушку
Клиент - то же самое, только для подключения.
Т.к. это разные приложения, нужно включить элементы выбора IP:port в каждом из них

--Endpoint--
| IP : _____|
| Port: ____|
| __________|

-----------------------------------------------
В ОС Windows за работу с сетевыми сокетами отвечает модуль WSA (WinSocket API), со временем известен как просто WinSocket
#pragma comment (lib, "Ws2_32.lib")
и cpp-библиотеки (! до подключения Windows.h)
#include <WinSock2.h>
#include <WS2tcpip.h>

При работе серверного приложения присутстуют два сокета 
 "слушающий сокет" - постоянно работающий сокет, отвечающий за приём подключений
 "обменный сокет" - открываемый при подключения клиента, передающий данные между ними 

! При анализе ошибок не рекомендуется несколько раз вызывать WSAGetLastError() для последовательных сравнений
  Кроме повышенной трудоемкости (за счет вызовов) возможен "сброс" ошибки - сам вызов WSAGetLastError() завершается успешно,
  то есть ошибки нет	

Не нужно:
if( WSAGetLastError() == 10049) {////}
if( WSAGetLastError() == 10048) {////}
if( WSAGetLastError() == 10047) {////}

Нужно:
int lastError = WSAGetLastError();
if( lastError == 10048) {/////}
if( lastError == 10048) {/////}
if( lastError == 10047) {/////}

Буферизация.

---------------------------------------------------------
Сериализация - Десериализация
Объект, как комплексный элемент, можно представить в виде "параллельных" данных. В то же время сеть - позволяет только последовательную
	передачу (в одном проводе не может быть двух напряжений одновременно, одна антенна не может излучать несколько сигналов сразу)

Процесс преобразования объекта, при котором он становится пригодным для сохранения или передачи, называют сериализацией 
(от англ. - последовательный). Обратный процесс - десериализация.

-----------------------------------------------------
Сериализация массивов (практическая работа)
Задание: 
1. Обеспечить хранение массивов сообщений на сервере
	(а) в виде списка, который расширяется
	(б) последние 100 сообщений (остальные удалять из массива)
	- выбрать один из вариантов - а) или б)
2. Создать методы (функции) сериализации и десериализации массива: принимает строку, возвращает массив объектов
3. Изменить функциональность сервера:
	в ответ клиенту отправляются все ранее полученные сообщения
4. Изменить функциональность клиента:
	т.к. сервер пересылает все сообщения, по ответу сервера зачищать "чат" и заполнять полученными данными
5. Проверить работу, запустив несколько окон "клиента"

----------------------------------------------------------------
1. Запускать таймер обновления сообщений отдельной кнопкой (Подключиться к серверу / Войти)
2. Переделать функцию отправки запроса на сервер, передавать данные для отправки в параметрах 
	(убрать повторяющийся код из функций SyncMessage & SendMessage)
3. Реорганизовать цикл десериализации сообщений (убрать повторяющийся код)
4. Обеспечить синхронизацию отправки сообщений клиентом (чтобы нажатие кнопки "Отправить" не совпало с автоматическое синхронизацией)

-----------------------------------------------------------------
Идентификация сообщений
проблема: при получении сообщения о сервера клиент полностью обновляет "чат". На самом деле, ряд сообщений не требует ряд обновления, 
		  т.к. были загружены ранее.
особенность: проверять сообщения по "полному контенту" трудоемко, соизмеримо с тем, чтобы просто заменить. 
пути решения: добавить в сообщение его идентификатор - значение, которое "легко" сравнивается и позволяет определить, что данное сообщение уже отображено. 

-----------------------------------------------------------------
Идентификация пользователя
/***************************************************************************************************************************************\
|  При старте клиента, при подключении к серверу (первому) передается (на сервер) данные о введенном логине.						    |
|  Сервер отвечает - логин свободен или занят (сервер хранит массив подключенных логинов).												|
|  Если клиент получает OK, то поле логина блокируется от записи (нельзя изменить), иначе - кнопка "отправить" не активируется.			|
|  																																		|
|  Лог выводит сообщение о занятом логине, при отключении от сервера или при закрытии окна посылается сообщение о выходе логина из чата.| 
|  Со стороны сервера принимается и анализируются сообщения авторизации и ведется массив "занятых" логинов.								|
|  использовать 201 код реквест хттп - 201 принят, 401 - не авторизован.                                								|
\**************************************************************************************************************************************/

Идея решения:
(префиксная) - добавить первым символом сообщения такой, который нельзя ввести с клавиатуры.
например, \b (backspace)

Посылать серверу ID удаляемого сообщения, после чего сравнивать айди на сервере со всеми существующими и удалять в случае нахождения.